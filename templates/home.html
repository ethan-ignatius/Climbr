{% extends "base.html" %}
{% block title %}ClimbApp - Discover Routes{% endblock %}

{% block content %}
<div class="map-container">
  <div id="map" class="climbing-map"></div>
  
  <!-- Floating search bar -->
  <div class="search-overlay">
    <div class="search-bar">
      <input type="text" id="search-input" placeholder="Search locations (e.g. Yosemite, Boulder, etc.)" />
      <button id="search-btn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
      </button>
      <div id="search-results" class="search-results hidden"></div>
    </div>
  </div>

  <!-- Route details popup -->
  <div id="route-popup" class="route-popup hidden">
    <div class="route-popup-content">
      <button id="close-popup" class="close-btn">&times;</button>
      <div id="popup-body"></div>
    </div>
  </div>

  <!-- Floating action button for adding routes -->
  {% if user.is_authenticated %}
  <div class="fab-container">
    <a href="{% url 'routes:add' %}" class="fab">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    </a>
  </div>
  {% endif %}
</div>

<style>
.map-container {
  position: relative;
  width: 100vw;
  height: 100vh;
  margin-left: calc(-50vw + 50%);
  margin-right: calc(-50vw + 50%);
  margin-top: -2rem;
  margin-bottom: -2rem;
}

.climbing-map {
  width: 100%;
  height: 100%;
  z-index: 1;
}

.search-overlay {
  position: absolute;
  top: 120px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  justify-content: center;
}

.search-bar {
  position: relative;
  display: flex;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 25px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  overflow: visible;
  width: 100%;
  max-width: 500px;
}

.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(15px);
  border-radius: 15px;
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
  margin-top: 5px;
  max-height: 200px;
  overflow-y: auto;
  z-index: 1001;
}

.search-result-item {
  padding: 12px 20px;
  cursor: pointer;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: rgba(37, 99, 235, 0.1);
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-main {
  font-weight: 500;
  color: #111827;
  font-size: 14px;
}

.search-result-subtitle {
  font-size: 12px;
  color: #6b7280;
  margin-top: 2px;
}

.popular-suggestion {
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.05), rgba(245, 158, 11, 0.02));
  border-left: 3px solid rgba(245, 158, 11, 0.3);
}

.popular-suggestion:hover {
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));
}

.search-bar input {
  flex: 1;
  border: none;
  padding: 12px 20px;
  font-size: 16px;
  background: transparent;
  outline: none;
}

.search-bar button {
  border: none;
  background: transparent;
  padding: 12px 15px;
  cursor: pointer;
  color: #666;
  transition: color 0.2s;
}

.search-bar button:hover {
  color: #333;
}

.route-popup {
  position: absolute;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  background: white;
  border-radius: 20px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
  max-height: 60vh;
  overflow-y: auto;
  transform: translateY(100%);
  transition: transform 0.3s ease-out;
}

.route-popup:not(.hidden) {
  transform: translateY(0);
}

.route-popup-content {
  position: relative;
  padding: 20px;
}

.close-btn {
  position: absolute;
  top: 15px;
  right: 20px;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #666;
  padding: 5px;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.close-btn:hover {
  background: #f0f0f0;
}

.fab-container {
  position: absolute;
  bottom: 30px;
  right: 30px;
  z-index: 1000;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 56px;
  height: 56px;
  background: #2563eb;
  color: white;
  border-radius: 50%;
  box-shadow: 0 4px 20px rgba(37, 99, 235, 0.3);
  text-decoration: none;
  transition: all 0.3s ease;
}

.fab:hover {
  background: #1d4ed8;
  transform: scale(1.1);
  box-shadow: 0 6px 25px rgba(37, 99, 235, 0.4);
}

.route-marker {
  background: transparent !important;
  border: 0 !important;
  box-shadow: none !important;
}

/* The only visible pin */
.route-marker .route-dot {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: 700;
  font-size: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,.3);
}

.user-location-marker {
  background: transparent !important;
  border: none !important;
}

.user-location-dot {
  position: relative;
  width: 20px;
  height: 20px;
}

.user-location-center {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 8px;
  height: 8px;
  background: #1e40af;
  border: 2px solid white;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  z-index: 2;
}

.user-location-pulse {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  background: rgba(30, 64, 175, 0.3);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: translate(-50%, -50%) scale(0.5);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(2);
    opacity: 0;
  }
}

.route-info {
  text-align: left;
}

.route-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 8px;
  color: #333;
}

.route-meta {
  display: flex;
  gap: 15px;
  margin-bottom: 10px;
  font-size: 14px;
  color: #666;
}

.route-difficulty {
  background: #f3f4f6;
  padding: 4px 8px;
  border-radius: 12px;
  font-weight: 500;
}

.route-description {
  color: #555;
  line-height: 1.5;
  margin-bottom: 15px;
}

.route-actions {
  display: flex;
  gap: 10px;
}

.btn-view {
  background: #2563eb;
  color: white;
  text-decoration: none;
  padding: 8px 16px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 500;
  transition: background 0.2s;
}

.btn-view:hover {
  background: #1d4ed8;
  text-decoration: none;
  color: white;
}

/* Favorite button styles */
.btn-favorite {
  display: flex;
  align-items: center;
  gap: 6px;
  background: transparent;
  border: 1px solid #e5e7eb;
  color: #6b7280;
  padding: 8px 12px;
  border-radius: 12px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-favorite:hover {
  border-color: #ef4444;
  color: #ef4444;
}

.btn-favorite.favorited {
  border-color: #ef4444;
  color: #ef4444;
  background: rgba(239, 68, 68, 0.05);
}

.btn-favorite .heart-icon {
  font-size: 16px;
}

/* Vote buttons styles */
.vote-buttons {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #f3f4f6;
}

.btn-vote {
  display: flex;
  align-items: center;
  gap: 4px;
  background: transparent;
  border: 1px solid #e5e7eb;
  color: #6b7280;
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 50px;
  justify-content: center;
}

.btn-vote:hover {
  border-color: #d1d5db;
  background: #f9fafb;
}

.btn-vote.upvote.active {
  border-color: #10b981;
  color: #10b981;
  background: rgba(16, 185, 129, 0.05);
}

.btn-vote.downvote.active {
  border-color: #ef4444;
  color: #ef4444;
  background: rgba(239, 68, 68, 0.05);
}

.vote-display {
  display: flex;
  gap: 12px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #f3f4f6;
  font-size: 13px;
  color: #6b7280;
}

.vote-count {
  display: flex;
  align-items: center;
  gap: 2px;
}

/* Favorite heart on map markers */
.favorite-heart {
  position: absolute;
  top: -8px;
  right: -8px;
  font-size: 12px;
  background: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.hidden {
  display: none;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .search-overlay {
    left: 10px;
    right: 10px;
    top: 110px;
  }
  
  .search-bar {
    max-width: none;
  }
  
  .search-bar input {
    padding: 10px 16px;
    font-size: 15px;
  }
  
  .route-popup {
    left: 10px;
    right: 10px;
    bottom: 10px;
  }
  
  .fab-container {
    bottom: 20px;
    right: 20px;
  }
}

@media (max-width: 480px) {
  .search-overlay {
    top: 105px;
  }
}
</style>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />

<!-- Django data injection using JSON script tags -->
{{ user_location|json_script:"user-location-data" }}
{{ routes|json_script:"routes-data" }}
{{ request.user.is_authenticated|json_script:"user-auth-data" }}

<script>
// Parse Django data from JSON script tags
const userLocationElement = document.getElementById('user-location-data');
const userLocation = userLocationElement ? JSON.parse(userLocationElement.textContent) : null;

const routesElement = document.getElementById('routes-data');
const routesData = routesElement ? JSON.parse(routesElement.textContent) : [];

const authElement = document.getElementById('user-auth-data');
const isAuthenticated = authElement ? JSON.parse(authElement.textContent) : false;

// Process routes data for the map (data is already in the right format)
const routes = routesData.map(route => ({
  id: route.pk,
  title: route.title,
  description: route.description,
  difficulty: route.difficulty,
  author: route.author,
  location: route.location_name,
  lat: route.latitude,
  lng: route.longitude,
  detailUrl: `/routes/${route.pk}/`,
  is_favorited: route.is_favorited || false,
  upvotes_count: route.upvotes_count || 0,
  downvotes_count: route.downvotes_count || 0,
  user_vote: route.user_vote || null
}));

// Initialize the map
let initialView = [39.7392, -104.9903]; // Default: Colorado
let initialZoom = 6;

// If user has location, center on it
if (userLocation) {
  initialView = [userLocation.latitude, userLocation.longitude];
  initialZoom = 10; // Closer zoom for user's area
}

const map = L.map('map', {
  zoomControl: false,
  attributionControl: false
}).setView(initialView, initialZoom);

// Add zoom control to top right
L.control.zoom({
  position: 'topright'
}).addTo(map);

// Add tile layer
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
}).addTo(map);

// let user click anywhere to add a route
map.on('click', function (e) {
  const lat = e.latlng.lat.toFixed(6);
  const lng = e.latlng.lng.toFixed(6);

  // only show the button if the user is logged in
  const addUrl = "{% url 'routes:add' %}?lat=" + lat + "&lng=" + lng;

  const html = `
    <div style="text-align:center;">
      <p>Add a route here?</p>
      <a href="${addUrl}" class="btn btn-primary" style="padding:6px 12px; border-radius:6px; display:inline-block;">
        Go to Add Route
      </a>
    </div>
  `;

  L.popup()
    .setLatLng(e.latlng)
    .setContent(html)
    .openOn(map);
});

const createMarkerIcon = (difficulty, isFavorited = false) => {
  const color =
    difficulty <= 3 ? '#10b981' :
    difficulty <= 6 ? '#f59e0b' : '#ef4444';
  
  const favoriteHeart = isFavorited ? 
    `<div class="favorite-heart">‚ù§Ô∏è</div>` : '';

  return L.divIcon({
    className: 'route-marker',
    html: `
      <div class="route-dot" style="background:${color}">${difficulty}</div>
      ${favoriteHeart}
    `,
    iconSize: [24, 24],
    iconAnchor: [12, 12]
  });
};

/* ---------------------------------------------------------------------------
   Geocoding support for routes that only have location text (no lat/lng).
   We use Nominatim and take the FIRST result. Results are cached in
   localStorage and requests are rate-limited to be polite.
--------------------------------------------------------------------------- */
const GEOCACHE_KEY = 'Climbr.geocodeCache.v1';
const _geoCacheObj = JSON.parse(localStorage.getItem(GEOCACHE_KEY) || '{}');
const geocodeCache = new Map(Object.entries(_geoCacheObj));

function persistGeocodeCache() {
  localStorage.setItem(GEOCACHE_KEY, JSON.stringify(Object.fromEntries(geocodeCache)));
}

let lastGeocodeAt = 0;
async function rateLimitGeocode() {
  const elapsed = Date.now() - lastGeocodeAt;
  const wait = Math.max(0, 1100 - elapsed); // ~1 request/sec
  if (wait) await new Promise(r => setTimeout(r, wait));
  lastGeocodeAt = Date.now();
}

/** Returns {lat, lng} or null. Uses first Nominatim result. */
async function geocodeFirstResult(query) {
  if (!query) return null;
  const key = query.trim().toLowerCase();
  if (geocodeCache.has(key)) return geocodeCache.get(key);

  await rateLimitGeocode();

  const params = new URLSearchParams({
    q: query,
    format: 'jsonv2',
    limit: '1',
    addressdetails: '0',
    // Add your contact email below; Nominatim requests one.
    email: 'you@example.com'
  });

  const url = `https://nominatim.openstreetmap.org/search?${params.toString()}`;
  try {
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!res.ok) throw new Error(`Geocode HTTP ${res.status}`);
    const json = await res.json();
    if (!json || !json.length) {
      geocodeCache.set(key, null);
      persistGeocodeCache();
      return null;
    }
    const { lat, lon } = json[0];
    const coords = { lat: parseFloat(lat), lng: parseFloat(lon) };
    geocodeCache.set(key, coords);
    persistGeocodeCache();
    return coords;
  } catch (err) {
    console.error('Geocode error:', err);
    return null;
  }
}

/** Ensure a route has numeric {lat,lng}. If missing, geocode its location text. */
async function ensureRouteCoords(route) {
  const hasLat = Number.isFinite(route.lat);
  const hasLng = Number.isFinite(route.lng);
  if (hasLat && hasLng) return { lat: route.lat, lng: route.lng };

  const q = route.location || route.location_name || route.place || route.address;
  if (!q) return null;

  const coords = await geocodeFirstResult(q);
  if (coords) {
    // Persist on the object so subsequent renders don't need to geocode again
    route.lat = coords.lat;
    route.lng = coords.lng;
  }
  return coords;
}

/* ---------------------------------------------------------------------------
   Add markers (with geocoding fallback) and fit bounds
--------------------------------------------------------------------------- */
const routeLayer = L.layerGroup().addTo(map);

// Add user location marker if available
let userMarker = null;
if (userLocation) {
  // Create a pulsing circle for user location (like Google Maps)
  const userLocationIcon = L.divIcon({
    className: 'user-location-marker',
    html: `
      <div class="user-location-dot">
        <div class="user-location-pulse"></div>
        <div class="user-location-center"></div>
      </div>
    `,
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });

  userMarker = L.marker([userLocation.latitude, userLocation.longitude], {
    icon: userLocationIcon,
    zIndexOffset: 1000 // Keep user marker on top
  }).addTo(map);

  // Add tooltip for user location
  userMarker.bindTooltip('Your location', {
    permanent: false,
    direction: 'top',
    offset: [0, -10]
  });
}

const markers = [];

/** Renders markers for all routes, geocoding those that need it (first result). */
async function renderRouteMarkersAndFit() {
  routeLayer.clearLayers();
  markers.length = 0;

  for (const route of routes) {
    const coords = await ensureRouteCoords(route);
    if (!coords) continue;

    const marker = L.marker([coords.lat, coords.lng], {
      icon: createMarkerIcon(route.difficulty, route.is_favorited)
    }).addTo(routeLayer);

    marker.routeData = route;
    marker.on('click', () => showRoutePopup(route));
    markers.push(marker);
  }

  // Fit map to show all markers if any exist, otherwise use user location or default
  if (markers.length > 0 || userMarker) {
    const all = [...markers];
    if (userMarker) all.push(userMarker);
    const group = new L.featureGroup(all);
    try {
      map.fitBounds(group.getBounds().pad(0.1));
    } catch (e) {
      // If bounds are invalid for some reason, ignore and keep current view
      console.warn('fitBounds warning:', e);
    }
  }
}

// Kick off rendering
renderRouteMarkersAndFit();

/* ---------------------------------------------------------------------------
   Route popup
--------------------------------------------------------------------------- */
function showRoutePopup(route) {
  const popup = document.getElementById('route-popup');
  const popupBody = document.getElementById('popup-body');
  
  let favoriteButton = '';
  let voteButtons = '';
  
  if (isAuthenticated) {
    const favoriteClass = route.is_favorited ? 'favorited' : '';
    const heartIcon = route.is_favorited ? '‚ù§Ô∏è' : 'ü§ç';
    const favoriteText = route.is_favorited ? 'Favorited' : 'Favorite';
    
    favoriteButton = `
      <button class="btn-favorite ${favoriteClass}" 
              onclick="toggleFavorite(${route.id})" 
              data-route-id="${route.id}">
        <span class="heart-icon">${heartIcon}</span>
        <span class="favorite-text">${favoriteText}</span>
      </button>
    `;
    
    const upvoteActive = route.user_vote === true ? 'active' : '';
    const downvoteActive = route.user_vote === false ? 'active' : '';
    
    voteButtons = `
      <div class="vote-buttons">
        <button class="btn-vote upvote ${upvoteActive}" 
                onclick="voteRoute(${route.id}, true)" 
                data-route-id="${route.id}">
          <span class="vote-icon">üëç</span>
          <span class="vote-count">${route.upvotes_count || 0}</span>
        </button>
        <button class="btn-vote downvote ${downvoteActive}" 
                onclick="voteRoute(${route.id}, false)" 
                data-route-id="${route.id}">
          <span class="vote-icon">üëé</span>
          <span class="vote-count">${route.downvotes_count || 0}</span>
        </button>
      </div>
    `;
  } else {
    voteButtons = `
      <div class="vote-display">
        <span class="vote-count">üëç ${route.upvotes_count || 0}</span>
        <span class="vote-count">üëé ${route.downvotes_count || 0}</span>
      </div>
    `;
  }

  const locationDisplay = route.location ? `<span>üìç ${route.location}</span>` : '';

  popupBody.innerHTML = `
    <div class="route-info">
      <div class="route-title">${route.title}</div>
      <div class="route-meta">
        <span class="route-difficulty">V${route.difficulty}</span>
        <span>by ${route.author}</span>
        ${locationDisplay}
      </div>
      <div class="route-description">${route.description}</div>
      <div class="route-actions">
        <a href="${route.detailUrl}" class="btn-view">View Details</a>
        ${favoriteButton}
      </div>
      ${voteButtons}
    </div>
  `;

  popup.classList.remove('hidden');
}

// Close popup
document.getElementById('close-popup').addEventListener('click', function() {
  document.getElementById('route-popup').classList.add('hidden');
});

// Toggle favorite status for a route
async function toggleFavorite(routeId) {
  if (!isAuthenticated) {
    alert('Please log in to favorite routes.');
    return;
  }
  
  try {
    const response = await fetch(`/routes/${routeId}/favorite/`, {
      method: 'POST',
      headers: {
        'X-CSRFToken': getCsrfToken(),
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });
    
    const data = await response.json();
    
    if (data.success) {
      // Update the route data
      const route = routes.find(r => r.id === routeId);
      if (route) {
        route.is_favorited = data.is_favorited;
        
        // Update the button in the popup
        const button = document.querySelector(`[data-route-id="${routeId}"].btn-favorite`);
        if (button) {
          const heartIcon = button.querySelector('.heart-icon');
          const favoriteText = button.querySelector('.favorite-text');
          
          if (data.is_favorited) {
            button.classList.add('favorited');
            heartIcon.textContent = '‚ù§Ô∏è';
            favoriteText.textContent = 'Favorited';
          } else {
            button.classList.remove('favorited');
            heartIcon.textContent = 'ü§ç';
            favoriteText.textContent = 'Favorite';
          }
        }
        
        // Update the marker on the map
        const marker = markers.find(m => m.routeData.id === routeId);
        if (marker) {
          marker.setIcon(createMarkerIcon(route.difficulty, route.is_favorited));
        }
      }
    } else {
      alert('Error updating favorite: ' + data.error);
    }
  } catch (error) {
    console.error('Error toggling favorite:', error);
    alert('Error updating favorite. Please try again.');
  }
}

// Vote on a route (upvote or downvote)
async function voteRoute(routeId, isUpvote) {
  if (!isAuthenticated) {
    alert('Please log in to vote on routes.');
    return;
  }
  
  try {
    const response = await fetch(`/routes/${routeId}/vote/`, {
      method: 'POST',
      headers: {
        'X-CSRFToken': getCsrfToken(),
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: `is_upvote=${isUpvote}`
    });
    
    const data = await response.json();
    
    if (data.success) {
      // Update the route data
      const route = routes.find(r => r.id === routeId);
      if (route) {
        route.user_vote = data.user_vote;
        route.upvotes_count = data.upvotes_count;
        route.downvotes_count = data.downvotes_count;
        
        // Update the vote buttons in the popup
        const upvoteBtn = document.querySelector(`[data-route-id="${routeId}"].upvote`);
        const downvoteBtn = document.querySelector(`[data-route-id="${routeId}"].downvote`);
        
        if (upvoteBtn && downvoteBtn) {
          // Reset active states
          upvoteBtn.classList.remove('active');
          downvoteBtn.classList.remove('active');
          
          // Set active state based on user vote
          if (data.user_vote === true) {
            upvoteBtn.classList.add('active');
          } else if (data.user_vote === false) {
            downvoteBtn.classList.add('active');
          }
          
          // Update vote counts
          upvoteBtn.querySelector('.vote-count').textContent = data.upvotes_count;
          downvoteBtn.querySelector('.vote-count').textContent = data.downvotes_count;
        }
      }
    } else {
      alert('Error voting: ' + data.error);
    }
  } catch (error) {
    console.error('Error voting:', error);
    alert('Error voting. Please try again.');
  }
}

// Get CSRF token for AJAX requests
function getCsrfToken() {
  const cookies = document.cookie.split(';');
  for (let cookie of cookies) {
    const [name, value] = cookie.trim().split('=');
    if (name === 'csrftoken') {
      return value;
    }
  }
  // Fallback: try to get from meta tag or form
  const csrfMeta = document.querySelector('meta[name=csrf-token]');
  if (csrfMeta) return csrfMeta.getAttribute('content');
  
  const csrfInput = document.querySelector('input[name=csrfmiddlewaretoken]');
  if (csrfInput) return csrfInput.value;
  
  return '';
}

/* ---------------------------------------------------------------------------
   Search functionality with geocoding (unchanged other than being below)
--------------------------------------------------------------------------- */
const searchInput = document.getElementById('search-input');
const searchBtn = document.getElementById('search-btn');
const searchResults = document.getElementById('search-results');

let searchTimeout;
const searchCache = new Map(); // Cache for search results
let activeSearchController = null; // For cancelling requests

// Comprehensive local database for instant search results
const localLocationDatabase = [
  // Major US Cities
  { name: 'Los Angeles, CA', lat: 34.0522, lng: -118.2437, aliases: ['la', 'los angeles'] },
  { name: 'New York City, NY', lat: 40.7128, lng: -74.0060, aliases: ['nyc', 'new york', 'manhattan'] },
  { name: 'San Francisco, CA', lat: 37.7749, lng: -122.4194, aliases: ['sf', 'san francisco'] },
  { name: 'Chicago, IL', lat: 41.8781, lng: -87.6298, aliases: ['chi', 'chicago'] },
  { name: 'Houston, TX', lat: 29.7604, lng: -95.3698, aliases: ['hou', 'houston'] },
  { name: 'Phoenix, AZ', lat: 33.4484, lng: -112.0740, aliases: ['phx', 'phoenix'] },
  { name: 'Philadelphia, PA', lat: 39.9526, lng: -75.1652, aliases: ['philly', 'philadelphia'] },
  { name: 'San Antonio, TX', lat: 29.4241, lng: -98.4936, aliases: ['sa', 'san antonio'] },
  { name: 'San Diego, CA', lat: 32.7157, lng: -117.1611, aliases: ['sd', 'san diego'] },
  { name: 'Dallas, TX', lat: 32.7767, lng: -96.7970, aliases: ['dal', 'dallas'] },
  { name: 'Austin, TX', lat: 30.2672, lng: -97.7431, aliases: ['aus', 'austin'] },
  { name: 'Jacksonville, FL', lat: 30.3322, lng: -81.6557, aliases: ['jax', 'jacksonville'] },
  { name: 'Fort Worth, TX', lat: 32.7555, lng: -97.3308, aliases: ['fort worth'] },
  { name: 'Columbus, OH', lat: 39.9612, lng: -82.9988, aliases: ['columbus'] },
  { name: 'Indianapolis, IN', lat: 39.7684, lng: -86.1581, aliases: ['indy', 'indianapolis'] },
  { name: 'Charlotte, NC', lat: 35.2271, lng: -80.8431, aliases: ['charlotte'] },
  { name: 'Seattle, WA', lat: 47.6062, lng: -121.3321, aliases: ['sea', 'seattle'] },
  { name: 'Denver, CO', lat: 39.7392, lng: -104.9903, aliases: ['den', 'denver'] },
  { name: 'Washington, DC', lat: 38.9072, lng: -77.0369, aliases: ['dc', 'washington'] },
  { name: 'Boston, MA', lat: 42.3601, lng: -71.0589, aliases: ['boston'] },
  { name: 'Nashville, TN', lat: 36.1627, lng: -86.7816, aliases: ['nash', 'nashville'] },
  { name: 'Portland, OR', lat: 45.5152, lng: -122.6784, aliases: ['pdx', 'portland'] },
  { name: 'Las Vegas, NV', lat: 36.1699, lng: -115.1398, aliases: ['vegas', 'las vegas'] },
  { name: 'Detroit, MI', lat: 42.3314, lng: -83.0458, aliases: ['det', 'detroit'] },
  { name: 'Memphis, TN', lat: 35.1495, lng: -90.0490, aliases: ['mem', 'memphis'] },
  { name: 'Louisville, KY', lat: 38.2527, lng: -85.7585, aliases: ['louisville'] },
  { name: 'Baltimore, MD', lat: 39.2904, lng: -76.6122, aliases: ['baltimore'] },
  { name: 'Milwaukee, WI', lat: 43.0389, lng: -87.9065, aliases: ['milwaukee'] },
  { name: 'Albuquerque, NM', lat: 35.0844, lng: -106.6504, aliases: ['albuquerque'] },
  { name: 'Tucson, AZ', lat: 32.2226, lng: -110.9747, aliases: ['tucson'] },
  { name: 'Fresno, CA', lat: 36.7378, lng: -119.7871, aliases: ['fresno'] },
  { name: 'Sacramento, CA', lat: 38.5816, lng: -121.4944, aliases: ['sac', 'sacramento'] },
  { name: 'Mesa, AZ', lat: 33.4152, lng: -111.8315, aliases: ['mesa'] },
  { name: 'Kansas City, MO', lat: 39.0997, lng: -94.5786, aliases: ['kc', 'kansas city'] },
  { name: 'Atlanta, GA', lat: 33.7490, lng: -84.3880, aliases: ['atl', 'atlanta'] },
  { name: 'Colorado Springs, CO', lat: 38.8339, lng: -104.8214, aliases: ['colorado springs'] },
  { name: 'Raleigh, NC', lat: 35.7796, lng: -78.6382, aliases: ['raleigh'] },
  { name: 'Omaha, NE', lat: 41.2565, lng: -95.9345, aliases: ['omaha'] },
  { name: 'Miami, FL', lat: 25.7617, lng: -80.1918, aliases: ['mia', 'miami'] },
  { name: 'Oakland, CA', lat: 37.8044, lng: -122.2712, aliases: ['oak', 'oakland'] },
  { name: 'Minneapolis, MN', lat: 44.9778, lng: -93.2650, aliases: ['minneapolis'] },
  { name: 'Tulsa, OK', lat: 36.1540, lng: -95.9928, aliases: ['tulsa'] },
  { name: 'Cleveland, OH', lat: 41.4993, lng: -81.6944, aliases: ['cleveland'] },
  { name: 'Wichita, KS', lat: 37.6872, lng: -97.3301, aliases: ['wichita'] },
  { name: 'Arlington, TX', lat: 32.7357, lng: -97.1081, aliases: ['arlington'] },
  { name: 'New Orleans, LA', lat: 29.9511, lng: -90.0715, aliases: ['nola', 'new orleans'] },
  { name: 'Bakersfield, CA', lat: 35.3733, lng: -119.0187, aliases: ['bakersfield'] },
  { name: 'Tampa, FL', lat: 27.9506, lng: -82.4572, aliases: ['tampa'] },
  { name: 'Honolulu, HI', lat: 21.3099, lng: -157.8581, aliases: ['honolulu'] },
  { name: 'Aurora, CO', lat: 39.7294, lng: -104.8319, aliases: ['aurora'] },
  { name: 'Anaheim, CA', lat: 33.8366, lng: -117.9143, aliases: ['anaheim'] },
  { name: 'Santa Ana, CA', lat: 33.7455, lng: -117.8677, aliases: ['santa ana'] },
  { name: 'St. Louis, MO', lat: 38.6270, lng: -90.1994, aliases: ['st louis', 'saint louis'] },
  { name: 'Riverside, CA', lat: 33.9533, lng: -117.3962, aliases: ['riverside'] },
  { name: 'Corpus Christi, TX', lat: 27.8006, lng: -97.3964, aliases: ['corpus christi'] },
  { name: 'Lexington, KY', lat: 38.0406, lng: -84.5037, aliases: ['lexington'] },
  { name: 'Pittsburgh, PA', lat: 40.4406, lng: -79.9959, aliases: ['pittsburgh'] },
  { name: 'Anchorage, AK', lat: 61.2181, lng: -149.9003, aliases: ['anchorage'] },
  { name: 'Stockton, CA', lat: 37.9577, lng: -121.2908, aliases: ['stockton'] },
  { name: 'Cincinnati, OH', lat: 39.1031, lng: -84.5120, aliases: ['cincinnati'] },
  { name: 'St. Paul, MN', lat: 44.9537, lng: -93.0900, aliases: ['st paul', 'saint paul'] },
  { name: 'Smith Rock, OR', lat: 44.3672, lng: -121.1403, aliases: ['smith rock'], isClimbing: true },
  { name: 'Devils Tower, WY', lat: 44.5902, lng: -104.7139, aliases: ['devils tower'], isClimbing: true },
  { name: 'Red Rocks, NV', lat: 36.1353, lng: -115.4266, aliases: ['red rocks'], isClimbing: true },
  { name: 'Index, WA', lat: 47.8205, lng: -121.5537, aliases: ['index'], isClimbing: true },
  { name: 'Squamish, BC', lat: 49.7016, lng: -123.1558, aliases: ['squamish'], isClimbing: true },
  { name: 'Shawangunks, NY', lat: 41.7326, lng: -74.2104, aliases: ['gunks', 'shawangunks', 'new paltz'], isClimbing: true },
  { name: 'Seneca Rocks, WV', lat: 38.8348, lng: -79.3767, aliases: ['seneca', 'seneca rocks'], isClimbing: true },
  { name: 'Bishop, CA', lat: 37.3614, lng: -118.3959, aliases: ['bishop'], isClimbing: true },
  { name: 'Mammoth Lakes, CA', lat: 37.6485, lng: -118.9723, aliases: ['mammoth'], isClimbing: true },
  { name: 'Tahoe, CA', lat: 39.0968, lng: -120.0324, aliases: ['tahoe', 'lake tahoe'], isClimbing: true },
  { name: 'Tuolumne Meadows, CA', lat: 37.8747, lng: -119.3514, aliases: ['tuolumne'], isClimbing: true },
  { name: 'Hueco Tanks, TX', lat: 31.9209, lng: -106.0476, aliases: ['hueco'], isClimbing: true },
  { name: 'Ten Sleep, WY', lat: 44.0347, lng: -107.4481, aliases: ['ten sleep'], isClimbing: true },
  { name: 'Lander, WY', lat: 42.8330, lng: -108.7307, aliases: ['lander'], isClimbing: true },
  { name: 'Indian Creek, UT', lat: 38.4333, lng: -109.5167, aliases: ['indian creek'], isClimbing: true },
  { name: 'Zion, UT', lat: 37.2982, lng: -113.0263, aliases: ['zion'], isClimbing: true },
  { name: 'Black Canyon, CO', lat: 38.5753, lng: -107.7416, aliases: ['black canyon'], isClimbing: true },
  { name: 'City of Rocks, ID', lat: 42.0667, lng: -113.7000, aliases: ['city of rocks'], isClimbing: true },
  { name: 'Cochise Stronghold, AZ', lat: 31.9167, lng: -109.9667, aliases: ['cochise'], isClimbing: true },
  { name: 'Mount Washington, NH', lat: 44.2706, lng: -71.3033, aliases: ['mount washington', 'north conway'], isClimbing: true },
  { name: 'Rumney, NH', lat: 43.7834, lng: -71.8223, aliases: ['rumney'], isClimbing: true },
  { name: 'Adirondacks, NY', lat: 43.8555, lng: -74.3565, aliases: ['adirondacks'], isClimbing: true },
  { name: 'Acadia, ME', lat: 44.3386, lng: -68.2733, aliases: ['acadia'], isClimbing: true }
];

// Create search index for faster lookups
const searchIndex = new Map();
localLocationDatabase.forEach((location, index) => {
  // Index by name
  const nameParts = location.name.toLowerCase().split(/[\s,]+/);
  nameParts.forEach(part => {
    if (part.length > 0) {
      if (!searchIndex.has(part)) searchIndex.set(part, []);
      searchIndex.get(part).push(index);
    }
  });

  // Index by aliases
  location.aliases.forEach(alias => {
    const aliasParts = alias.toLowerCase().split(/[\s,]+/);
    aliasParts.forEach(part => {
      if (part.length > 0) {
        if (!searchIndex.has(part)) searchIndex.set(part, []);
        searchIndex.get(part).push(index);
      }
    });
  });
});

// Fast local search function - instant results
function performLocalSearch(query) {
  if (!query || query.length === 0) {
    hideSearchResults();
    return;
  }

  const queryLower = query.toLowerCase().trim();
  const resultIndices = new Set();

  // Search through all query parts
  const queryParts = queryLower.split(/[\s,]+/);

  queryParts.forEach(part => {
    if (part.length > 0) {
      // Exact matches first
      if (searchIndex.has(part)) {
        searchIndex.get(part).forEach(idx => resultIndices.add(idx));
      }

      // Prefix matches
      for (const [key, indices] of searchIndex.entries()) {
        if (key.startsWith(part) && key !== part) {
          indices.forEach(idx => resultIndices.add(idx));
        }
      }
    }
  });

  // Convert to array and get location objects
  const results = Array.from(resultIndices)
    .map(idx => localLocationDatabase[idx])
    .filter(loc => loc) // Remove any undefined entries
    .sort((a, b) => {
      // Prioritize climbing areas for climbing-related queries
      const queryIsClimbing = queryLower.includes('climb') || queryLower.includes('rock') || queryLower.includes('boulder');

      if (queryIsClimbing) {
        if (a.isClimbing && !b.isClimbing) return -1;
        if (!a.isClimbing && b.isClimbing) return 1;
      }

      // Score by relevance
      const aScore = calculateLocalRelevanceScore(a, queryLower);
      const bScore = calculateLocalRelevanceScore(b, queryLower);

      return bScore - aScore;
    })
    .slice(0, 6); // Limit to 6 results

  if (results.length > 0) {
    showLocalResults(results);
  } else {
    hideSearchResults();
  }
}

// Calculate relevance score for local results
function calculateLocalRelevanceScore(location, query) {
  const name = location.name.toLowerCase();
  let score = 0;

  // Exact name match
  if (name === query) return 1000;

  // Starts with query
  if (name.startsWith(query)) score += 500;

  // Contains query
  if (name.includes(query)) score += 100;

  // Check aliases
  for (const alias of location.aliases) {
    const aliasLower = alias.toLowerCase();
    if (aliasLower === query) score += 800;
    if (aliasLower.startsWith(query)) score += 400;
    if (aliasLower.includes(query)) score += 50;
  }

  // Boost climbing areas
  if (location.isClimbing) score += 25;

  // Boost popular cities (rough approximation by coordinate commonality)
  const isPopular = location.name.includes('Los Angeles') || 
                   location.name.includes('New York') || 
                   location.name.includes('Chicago') || 
                   location.name.includes('San Francisco') ||
                   location.name.includes('Seattle') ||
                   location.name.includes('Denver');
  if (isPopular) score += 10;

  return score;
}

// Show local search results
function showLocalResults(results) {
  const fragment = document.createDocumentFragment();

  results.forEach(location => {
    const item = document.createElement('div');
    item.className = `search-result-item${location.isClimbing ? ' popular-suggestion' : ''}`;

    const icon = location.isClimbing ? 
      `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline; margin-right: 6px; color: #f59e0b;">
        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
        <circle cx="12" cy="10" r="3"></circle>
      </svg>` : '';

    const subtitle = location.isClimbing ? 'Climbing area' : 'City';

    item.innerHTML = `
      <div class="search-result-main">${icon}${location.name}</div>
      <div class="search-result-subtitle">${subtitle}</div>
    `;

    item.addEventListener('click', () => {
      searchInput.value = location.name;
      hideSearchResults();
      map.setView([location.lat, location.lng], location.isClimbing ? 13 : 11);
    });

    fragment.appendChild(item);
  });

  searchResults.innerHTML = '';
  searchResults.appendChild(fragment);
  searchResults.classList.remove('hidden');
}

// Instant local search with minimal debouncing
function debounceSearch() {
  clearTimeout(searchTimeout);

  // Cancel any ongoing API request
  if (activeSearchController) {
    activeSearchController.abort();
    activeSearchController = null;
  }

  const query = searchInput.value.trim();

  // Instant local search for any length query
  if (query.length > 0) {
    performLocalSearch(query);
  } else {
    hideSearchResults();
  }

  // Only use API as fallback for longer queries with delay
  if (query.length >= 4) {
    searchTimeout = setTimeout(() => {
      // Only call API if local search didn't find good results
      const hasGoodLocalResults = !searchResults.classList.contains('hidden') && 
                                 searchResults.children.length >= 3;

      if (!hasGoodLocalResults) {
        performGeocodingSearch(query);
      }
    }, 500); // Longer delay since local search is instant
  }
}

// Simple query expansion for API fallback
function expandQuery(query) {
  // The local database handles aliases, so just return the query
  return query;
}

// Optimized geocoding search with caching and single request
async function performGeocodingSearch(query) {
  // Check cache first
  const cacheKey = query.toLowerCase().trim();
  if (searchCache.has(cacheKey)) {
    const cachedResults = searchCache.get(cacheKey);
    showSearchResults(cachedResults);
    return;
  }

  try {
    // Cancel any previous request
    if (activeSearchController) {
      activeSearchController.abort();
    }

    // Create new abort controller
    activeSearchController = new AbortController();

    const expandedQuery = expandQuery(query);

    // Single optimized request instead of multiple parallel requests
    const searchQuery = expandedQuery !== query ? expandedQuery : query;

    const response = await fetch(
      `https://nominatim.openstreetmap.org/search?format=json&limit=8&q=${encodeURIComponent(searchQuery)}&countrycodes=us&addressdetails=1&dedupe=1`,
      { 
        signal: activeSearchController.signal,
        headers: {
          'User-Agent': 'Climbr/1.0'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const results = await response.json();

    // Fast sorting by relevance
    const sortedResults = results.sort((a, b) => {
      const aName = a.display_name.toLowerCase();
      const bName = b.display_name.toLowerCase();
      const queryLower = query.toLowerCase();

      // Quick relevance scoring
      const aScore = calculateRelevanceScore(aName, queryLower);
      const bScore = calculateRelevanceScore(bName, queryLower);

      if (aScore !== bScore) return bScore - aScore;

      // Fallback to importance
      const aImportance = parseFloat(a.importance || 0);
      const bImportance = parseFloat(b.importance || 0);
      return bImportance - aImportance;
    });

    const finalResults = sortedResults.slice(0, 5);

    // Cache results for future use
    searchCache.set(cacheKey, finalResults);

    // Clear cache if it gets too large (prevent memory leaks)
    if (searchCache.size > 100) {
      const firstKey = searchCache.keys().next().value;
      searchCache.delete(firstKey);
    }

    showSearchResults(finalResults);

  } catch (error) {
    if (error.name === 'AbortError') {
      // Request was cancelled, ignore
      return;
    }
    console.error('Geocoding error:', error);
    hideSearchResults();
  } finally {
    activeSearchController = null;
  }
}

// Fast relevance scoring function
function calculateRelevanceScore(text, query) {
  if (text.startsWith(query)) return 100; // Perfect prefix match
  if (text.includes(query)) return 50;     // Contains query

  // Check for word matches
  const textWords = text.split(/[\s,]+/);
  const queryWords = query.split(/\s+/);

  let wordMatches = 0;
  for (const queryWord of queryWords) {
    for (const textWord of textWords) {
      if (textWord.startsWith(queryWord)) {
        wordMatches += 10;
        break;
      }
    }
  }

  return wordMatches;
}

// Show search results dropdown - optimized for performance
function showSearchResults(results) {
  // Use DocumentFragment for faster DOM manipulation
  const fragment = document.createDocumentFragment();

  results.forEach(result => {
    const item = document.createElement('div');
    item.className = 'search-result-item';

    // Optimized formatting - less complex logic
    let displayName, subtitle;

    if (result.address) {
      const addr = result.address;
      const city = addr.city || addr.town || addr.village;
      const state = addr.state;
      const county = addr.county;

      if (city && state) {
        displayName = `${city}, ${state}`;
        if (county && county !== city) {
          subtitle = county;
        }
      } else if (county && state) {
        displayName = `${county}, ${state}`;
      } else {
        displayName = result.display_name.split(',').slice(0, 3).join(', ');
      }
    } else {
      displayName = result.display_name.split(',').slice(0, 3).join(', ');
    }

    // Create the item HTML
    item.innerHTML = `
      <div class="search-result-main">${displayName}</div>
      ${subtitle ? `<div class="search-result-subtitle">${subtitle}</div>` : ''}
    `;

    // Store data for faster access
    item._resultData = { result, displayName };
    item.addEventListener('click', () => {
      selectLocation(item._resultData.result, item._resultData.displayName);
    });

    fragment.appendChild(item);
  });

  // Single DOM update
  searchResults.innerHTML = '';
  searchResults.appendChild(fragment);
  searchResults.classList.remove('hidden');
}

// Hide search results dropdown
function hideSearchResults() {
  searchResults.classList.add('hidden');
}

// Select a location from search results
function selectLocation(result, displayName) {
  const lat = parseFloat(result.lat);
  const lng = parseFloat(result.lon);

  // Update search input
  searchInput.value = displayName;
  hideSearchResults();

  // Center map on selected location
  map.setView([lat, lng], 12);

  // Store in localStorage
  localStorage.setItem('Climbr-last-search', JSON.stringify({
    name: displayName,
    lat: lat,
    lng: lng
  }));
}

// Manual search button click
function performSearch() {
  const query = searchInput.value.trim();
  if (query) {
    performGeocodingSearch(query);
  }
}

// Event listeners with instant local search
searchInput.addEventListener('input', function(e) {
  const query = e.target.value.trim();

  // Instant local search for any input
  if (query.length > 0) {
    performLocalSearch(query);
  } else {
    hideSearchResults();
  }

  // Still run debounced search for API fallback
  debounceSearch();
});

searchInput.addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    e.preventDefault();
    performSearch();
  }
});

searchBtn.addEventListener('click', performSearch);

// Hide results when clicking outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.search-bar')) {
    hideSearchResults();
  }
});

// Close popup when clicking on map
map.on('click', function() {
  document.getElementById('route-popup').classList.add('hidden');
});
</script>
{% endblock %}